============================= test session starts ==============================
platform darwin -- Python 3.11.2, pytest-7.3.1, pluggy-1.0.0 -- /opt/homebrew/opt/python@3.11/bin/python3.11
cachedir: .pytest_cache
rootdir: /Users/ddolci/work/checkpoint_schedules
collecting ... collected 36 items

tests/test_validity.py::test_validity[1-25-5-h_revolve] n=25 s=5
1
s_ram =  1 s_disk =  4
FAILED
tests/test_validity.py::test_validity[1-25-10-h_revolve] n=25 s=10
1
s_ram =  1 s_disk =  9
PASSED
tests/test_validity.py::test_validity[1-25-15-h_revolve] n=25 s=15
1
s_ram =  1 s_disk =  14
PASSED
tests/test_validity.py::test_validity[1-100-10-h_revolve] n=100 s=10
1
s_ram =  1 s_disk =  9
FAILED
tests/test_validity.py::test_validity[1-100-20-h_revolve] n=100 s=20
1
s_ram =  1 s_disk =  19
FAILED
tests/test_validity.py::test_validity[1-100-30-h_revolve] n=100 s=30
1
s_ram =  1 s_disk =  29
PASSED
tests/test_validity.py::test_validity[1-250-25-h_revolve] n=250 s=25
1
s_ram =  1 s_disk =  24
FAILED
tests/test_validity.py::test_validity[1-250-50-h_revolve] n=250 s=50
1
s_ram =  1 s_disk =  49
FAILED
tests/test_validity.py::test_validity[1-250-75-h_revolve] n=250 s=75
1
s_ram =  1 s_disk =  74
PASSED
tests/test_validity.py::test_validity[1-250-100-h_revolve] n=250 s=100
1
s_ram =  1 s_disk =  99
PASSED
tests/test_validity.py::test_validity[1-250-125-h_revolve] n=250 s=125
1
s_ram =  1 s_disk =  124
PASSED
tests/test_validity.py::test_validity[1-250-150-h_revolve] n=250 s=150
1
s_ram =  1 s_disk =  149
PASSED
tests/test_validity.py::test_validity[3-25-5-h_revolve] n=25 s=5
3
s_ram =  4 s_disk =  1
PASSED
tests/test_validity.py::test_validity[3-25-10-h_revolve] n=25 s=10
3
s_ram =  7 s_disk =  3
PASSED
tests/test_validity.py::test_validity[3-25-15-h_revolve] n=25 s=15
3
s_ram =  10 s_disk =  5
PASSED
tests/test_validity.py::test_validity[3-100-10-h_revolve] n=100 s=10
3
s_ram =  7 s_disk =  3
PASSED
tests/test_validity.py::test_validity[3-100-20-h_revolve] n=100 s=20
3
s_ram =  14 s_disk =  6
PASSED
tests/test_validity.py::test_validity[3-100-30-h_revolve] n=100 s=30
3
s_ram =  20 s_disk =  10
PASSED
tests/test_validity.py::test_validity[3-250-25-h_revolve] n=250 s=25
3
s_ram =  17 s_disk =  8
PASSED
tests/test_validity.py::test_validity[3-250-50-h_revolve] n=250 s=50
3
s_ram =  34 s_disk =  16
PASSED
tests/test_validity.py::test_validity[3-250-75-h_revolve] n=250 s=75
3
s_ram =  50 s_disk =  25
PASSED
tests/test_validity.py::test_validity[3-250-100-h_revolve] n=250 s=100
3
s_ram =  67 s_disk =  33
PASSED
tests/test_validity.py::test_validity[3-250-125-h_revolve] n=250 s=125
3
s_ram =  84 s_disk =  41
PASSED
tests/test_validity.py::test_validity[3-250-150-h_revolve] n=250 s=150
3
s_ram =  100 s_disk =  50
PASSED
tests/test_validity.py::test_validity[5-25-5-h_revolve] n=25 s=5
5
s_ram =  4 s_disk =  1
PASSED
tests/test_validity.py::test_validity[5-25-10-h_revolve] n=25 s=10
5
s_ram =  8 s_disk =  2
PASSED
tests/test_validity.py::test_validity[5-25-15-h_revolve] n=25 s=15
5
s_ram =  12 s_disk =  3
PASSED
tests/test_validity.py::test_validity[5-100-10-h_revolve] n=100 s=10
5
s_ram =  8 s_disk =  2
PASSED
tests/test_validity.py::test_validity[5-100-20-h_revolve] n=100 s=20
5
s_ram =  16 s_disk =  4
PASSED
tests/test_validity.py::test_validity[5-100-30-h_revolve] n=100 s=30
5
s_ram =  24 s_disk =  6
PASSED
tests/test_validity.py::test_validity[5-250-25-h_revolve] n=250 s=25
5
s_ram =  20 s_disk =  5
PASSED
tests/test_validity.py::test_validity[5-250-50-h_revolve] n=250 s=50
5
s_ram =  40 s_disk =  10
PASSED
tests/test_validity.py::test_validity[5-250-75-h_revolve] n=250 s=75
5
s_ram =  60 s_disk =  15
PASSED
tests/test_validity.py::test_validity[5-250-100-h_revolve] n=250 s=100
5
s_ram =  80 s_disk =  20
PASSED
tests/test_validity.py::test_validity[5-250-125-h_revolve] n=250 s=125
5
s_ram =  100 s_disk =  25
PASSED
tests/test_validity.py::test_validity[5-250-150-h_revolve] n=250 s=150
5
s_ram =  120 s_disk =  30
PASSED

=================================== FAILURES ===================================
_______________________ test_validity[1-25-5-h_revolve] ________________________

schedule = <function h_revolve at 0x101b78fe0>, n = 25, S = 5, p = 1

    @pytest.mark.parametrize(
        "schedule",
        [
            #   (memory, {}),
            #  (periodic_disk, {"period": 1}),
            #  (periodic_disk, {"period": 2}),
            #  (periodic_disk, {"period": 7}),
            #  (periodic_disk, {"period": 10}),
            #  (multistage, {}),
            #  (two_level, {"period": 1}),
            #  (two_level, {"period": 2}),
            #  (two_level, {"period": 7}),
            #  (two_level, {"period": 10}),
            pytest.param(
                h_revolve),
            #  (mixed, {})
        ])
    @pytest.mark.parametrize("n, S", [
                                        (25, 5),
                                        (25, 10),
                                        (25, 15),
                                        (100, 10),
                                        (100, 20),
                                        (100, 30),
                                        (250, 25),
                                        (250, 50),
                                        (250, 75),
                                        (250, 100),
                                        (250, 125),
                                        (250, 150)
                                    ])
    @pytest.mark.parametrize("p", [1, 3, 5])
    def test_validity(schedule, n, S, p):
        """Test validity.
    
        Parameters
        ----------
        schedule : object
            Scheduler object.
        n : int
            Number of forward step to execute in the AC graph.
        S : tuple
            The number of slots in each level of memory.
    
        Raises
        ------
        TypeError
            Unexpected action.
        """
        @functools.singledispatch
        def action(cp_action):
            raise TypeError("Unexpected action")
    
        @action.register(Clear)
        def action_clear(cp_action):
            if cp_action.clear_ics:
                ics.clear()
            if cp_action.clear_data:
                data.clear()
    
        @action.register(Configure)
        def action_configure(cp_action):
            nonlocal store_ics, store_data
    
            store_ics = cp_action.store_ics
            store_data = cp_action.store_data
    
        @action.register(Write)
        def action_write(cp_action):
            assert len(ics) > 0 and len(sol) > 0
            if len(ics) > 0:
                assert cp_action.n == max(ics)
            snapshots[cp_action.storage][cp_action.n] = (set(ics), set(sol))
    
        @action.register(WriteForward)
        def action_write_forward(cp_action):
            assert len(ics) == 0 and len(data) > 0
            assert cp_action.n == max(data)
            assert data == cp_schedule.forward_data
            fwd_chk['RAM'][cp_action.n] = (set(data), set(sol))
    
        @action.register(Forward)
        def action_forward(cp_action):
            nonlocal model_n
            nonlocal sol
            assert model_n is not None and model_n == cp_action.n0
            assert cp_action.n0 < cp_action.n1
            assert len(sol) == 1 and cp_action.n0 in sol
            if cp_schedule.max_n() is not None:
                # Do not advance further than the current location of the adjoint
                assert cp_action.n1 <= n - model_r
    
            n1 = min(cp_action.n1, n)
            if store_ics:
                # No forward restart data for these steps is stored
                assert n1 not in snapshots["RAM"] and n1 not in snapshots["disk"]
            if store_data:
                assert n1 not in fwd_chk['RAM']
            model_n = n1
            if store_ics:
                ics.add(n1)
            if store_data:
                data.add(n1)
            if n1 == n:
                cp_schedule.finalize(n1)
            sol = set()
            sol.add(n1)
    
        @action.register(Reverse)
        def action_reverse(cp_action):
            nonlocal model_r
            # Start at the current location of the adjoint
            assert cp_action.n1 == n - model_r
            # Advance at least one step
            assert cp_action.n0 < cp_action.n1
            # Non-linear dependency data for these steps is stored
            sol.clear()
    
            model_r += cp_action.n1 - cp_action.n0
            if len(cp_schedule.forward_data) == 0:
                fwd_chk["RAM"].clear()
    
        @action.register(Read)
        def action_read(cp_action):
            nonlocal model_n
           # The checkpoint exists
            assert cp_action.n in snapshots[cp_action.storage]
    
            cp = snapshots[cp_action.storage][cp_action.n]
    
            # No data is currently stored for this step
            assert cp_action.n not in ics
            assert cp_action.n not in data
            # The checkpoint contains forward restart or non-linear dependency data
            assert len(cp[0]) > 0 or len(cp[1]) > 0
    
            # The checkpoint data is before the current location of the adjoint
            # print(cp_action.n, n, model_r)
            assert cp_action.n <= n - model_r
    
            model_n = None
    
            if len(cp[0]) > 0:
                ics.clear()
                ics.update(cp[0])
                model_n = cp_action.n
    
            if len(cp[1]) > 0:
                sol.clear()
                sol.update(cp[1])
    
            if cp_action.delete:
                del snapshots[cp_action.storage][cp_action.n]
    
        @action.register(EndForward)
        def action_end_forward(cp_action):
            # The correct number of forward steps has been taken
            assert model_n is not None and model_n == n
    
        @action.register(EndReverse)
        def action_end_reverse(cp_action):
            nonlocal model_r
    
            assert model_r == cp_schedule.max_n()
            assert len(data) == 0
            if not cp_action.exhausted:
                model_r = 0
    
        # for s in S:
        s=S
        # for p0 in p:
        p0 = p
        print(f"{n=:d} {s=:d}")
    
        model_n = 0
        model_r = 0
        init_condition = 0
        store_ics = False
        store_data = False
        ics = set()
        data = set()
        sol = set()
        snapshots = {"RAM": {}, "disk": {}}
        fwd_chk = {"RAM": {}}
    
        cp_schedule, storage_limits, data_limit = schedule(n, s, p0)  # noqa: E501
        if cp_schedule is None:
            pytest.skip("Incompatible with schedule type")
        assert cp_schedule.n() == 0
        assert cp_schedule.r() == 0
        assert s <= n
        assert cp_schedule.max_n() is None or cp_schedule.max_n() == n
        assert n >= 0
    
        def initial_condition(init_condition, sol, ics):
            """Set the initial condition.
            """
            nonlocal model_n
            sol.add(init_condition)
            ics.add(model_n)
    
        initial_condition(init_condition, sol, ics)
        c = 0
        while True:
            cp_action = next(cp_schedule)
            # print(cp_action, c)
            action(cp_action)
    
            assert model_n is None or model_n == cp_schedule.n()
            assert model_r == cp_schedule.r()
            # Checkpoint storage limits are not exceeded
            for storage_type, storage_limit in storage_limits.items():
>               assert len(snapshots[storage_type]) <= storage_limit
E               assert 5 <= 4
E                +  where 5 = len({0: ({0}, {0}), 2: ({2}, {2}), 7: ({7}, {7}), 12: ({12}, {12}), ...})

tests/test_validity.py:254: AssertionError
______________________ test_validity[1-100-10-h_revolve] _______________________

schedule = <function h_revolve at 0x101b78fe0>, n = 100, S = 10, p = 1

    @pytest.mark.parametrize(
        "schedule",
        [
            #   (memory, {}),
            #  (periodic_disk, {"period": 1}),
            #  (periodic_disk, {"period": 2}),
            #  (periodic_disk, {"period": 7}),
            #  (periodic_disk, {"period": 10}),
            #  (multistage, {}),
            #  (two_level, {"period": 1}),
            #  (two_level, {"period": 2}),
            #  (two_level, {"period": 7}),
            #  (two_level, {"period": 10}),
            pytest.param(
                h_revolve),
            #  (mixed, {})
        ])
    @pytest.mark.parametrize("n, S", [
                                        (25, 5),
                                        (25, 10),
                                        (25, 15),
                                        (100, 10),
                                        (100, 20),
                                        (100, 30),
                                        (250, 25),
                                        (250, 50),
                                        (250, 75),
                                        (250, 100),
                                        (250, 125),
                                        (250, 150)
                                    ])
    @pytest.mark.parametrize("p", [1, 3, 5])
    def test_validity(schedule, n, S, p):
        """Test validity.
    
        Parameters
        ----------
        schedule : object
            Scheduler object.
        n : int
            Number of forward step to execute in the AC graph.
        S : tuple
            The number of slots in each level of memory.
    
        Raises
        ------
        TypeError
            Unexpected action.
        """
        @functools.singledispatch
        def action(cp_action):
            raise TypeError("Unexpected action")
    
        @action.register(Clear)
        def action_clear(cp_action):
            if cp_action.clear_ics:
                ics.clear()
            if cp_action.clear_data:
                data.clear()
    
        @action.register(Configure)
        def action_configure(cp_action):
            nonlocal store_ics, store_data
    
            store_ics = cp_action.store_ics
            store_data = cp_action.store_data
    
        @action.register(Write)
        def action_write(cp_action):
            assert len(ics) > 0 and len(sol) > 0
            if len(ics) > 0:
                assert cp_action.n == max(ics)
            snapshots[cp_action.storage][cp_action.n] = (set(ics), set(sol))
    
        @action.register(WriteForward)
        def action_write_forward(cp_action):
            assert len(ics) == 0 and len(data) > 0
            assert cp_action.n == max(data)
            assert data == cp_schedule.forward_data
            fwd_chk['RAM'][cp_action.n] = (set(data), set(sol))
    
        @action.register(Forward)
        def action_forward(cp_action):
            nonlocal model_n
            nonlocal sol
            assert model_n is not None and model_n == cp_action.n0
            assert cp_action.n0 < cp_action.n1
            assert len(sol) == 1 and cp_action.n0 in sol
            if cp_schedule.max_n() is not None:
                # Do not advance further than the current location of the adjoint
                assert cp_action.n1 <= n - model_r
    
            n1 = min(cp_action.n1, n)
            if store_ics:
                # No forward restart data for these steps is stored
                assert n1 not in snapshots["RAM"] and n1 not in snapshots["disk"]
            if store_data:
                assert n1 not in fwd_chk['RAM']
            model_n = n1
            if store_ics:
                ics.add(n1)
            if store_data:
                data.add(n1)
            if n1 == n:
                cp_schedule.finalize(n1)
            sol = set()
            sol.add(n1)
    
        @action.register(Reverse)
        def action_reverse(cp_action):
            nonlocal model_r
            # Start at the current location of the adjoint
            assert cp_action.n1 == n - model_r
            # Advance at least one step
            assert cp_action.n0 < cp_action.n1
            # Non-linear dependency data for these steps is stored
            sol.clear()
    
            model_r += cp_action.n1 - cp_action.n0
            if len(cp_schedule.forward_data) == 0:
                fwd_chk["RAM"].clear()
    
        @action.register(Read)
        def action_read(cp_action):
            nonlocal model_n
           # The checkpoint exists
            assert cp_action.n in snapshots[cp_action.storage]
    
            cp = snapshots[cp_action.storage][cp_action.n]
    
            # No data is currently stored for this step
            assert cp_action.n not in ics
            assert cp_action.n not in data
            # The checkpoint contains forward restart or non-linear dependency data
            assert len(cp[0]) > 0 or len(cp[1]) > 0
    
            # The checkpoint data is before the current location of the adjoint
            # print(cp_action.n, n, model_r)
            assert cp_action.n <= n - model_r
    
            model_n = None
    
            if len(cp[0]) > 0:
                ics.clear()
                ics.update(cp[0])
                model_n = cp_action.n
    
            if len(cp[1]) > 0:
                sol.clear()
                sol.update(cp[1])
    
            if cp_action.delete:
                del snapshots[cp_action.storage][cp_action.n]
    
        @action.register(EndForward)
        def action_end_forward(cp_action):
            # The correct number of forward steps has been taken
            assert model_n is not None and model_n == n
    
        @action.register(EndReverse)
        def action_end_reverse(cp_action):
            nonlocal model_r
    
            assert model_r == cp_schedule.max_n()
            assert len(data) == 0
            if not cp_action.exhausted:
                model_r = 0
    
        # for s in S:
        s=S
        # for p0 in p:
        p0 = p
        print(f"{n=:d} {s=:d}")
    
        model_n = 0
        model_r = 0
        init_condition = 0
        store_ics = False
        store_data = False
        ics = set()
        data = set()
        sol = set()
        snapshots = {"RAM": {}, "disk": {}}
        fwd_chk = {"RAM": {}}
    
        cp_schedule, storage_limits, data_limit = schedule(n, s, p0)  # noqa: E501
        if cp_schedule is None:
            pytest.skip("Incompatible with schedule type")
        assert cp_schedule.n() == 0
        assert cp_schedule.r() == 0
        assert s <= n
        assert cp_schedule.max_n() is None or cp_schedule.max_n() == n
        assert n >= 0
    
        def initial_condition(init_condition, sol, ics):
            """Set the initial condition.
            """
            nonlocal model_n
            sol.add(init_condition)
            ics.add(model_n)
    
        initial_condition(init_condition, sol, ics)
        c = 0
        while True:
            cp_action = next(cp_schedule)
            # print(cp_action, c)
            action(cp_action)
    
            assert model_n is None or model_n == cp_schedule.n()
            assert model_r == cp_schedule.r()
            # Checkpoint storage limits are not exceeded
            for storage_type, storage_limit in storage_limits.items():
>               assert len(snapshots[storage_type]) <= storage_limit
E               assert 10 <= 9
E                +  where 10 = len({0: ({0}, {0}), 19: ({19}, {19}), 34: ({34}, {34}), 45: ({45}, {45}), ...})

tests/test_validity.py:254: AssertionError
______________________ test_validity[1-100-20-h_revolve] _______________________

schedule = <function h_revolve at 0x101b78fe0>, n = 100, S = 20, p = 1

    @pytest.mark.parametrize(
        "schedule",
        [
            #   (memory, {}),
            #  (periodic_disk, {"period": 1}),
            #  (periodic_disk, {"period": 2}),
            #  (periodic_disk, {"period": 7}),
            #  (periodic_disk, {"period": 10}),
            #  (multistage, {}),
            #  (two_level, {"period": 1}),
            #  (two_level, {"period": 2}),
            #  (two_level, {"period": 7}),
            #  (two_level, {"period": 10}),
            pytest.param(
                h_revolve),
            #  (mixed, {})
        ])
    @pytest.mark.parametrize("n, S", [
                                        (25, 5),
                                        (25, 10),
                                        (25, 15),
                                        (100, 10),
                                        (100, 20),
                                        (100, 30),
                                        (250, 25),
                                        (250, 50),
                                        (250, 75),
                                        (250, 100),
                                        (250, 125),
                                        (250, 150)
                                    ])
    @pytest.mark.parametrize("p", [1, 3, 5])
    def test_validity(schedule, n, S, p):
        """Test validity.
    
        Parameters
        ----------
        schedule : object
            Scheduler object.
        n : int
            Number of forward step to execute in the AC graph.
        S : tuple
            The number of slots in each level of memory.
    
        Raises
        ------
        TypeError
            Unexpected action.
        """
        @functools.singledispatch
        def action(cp_action):
            raise TypeError("Unexpected action")
    
        @action.register(Clear)
        def action_clear(cp_action):
            if cp_action.clear_ics:
                ics.clear()
            if cp_action.clear_data:
                data.clear()
    
        @action.register(Configure)
        def action_configure(cp_action):
            nonlocal store_ics, store_data
    
            store_ics = cp_action.store_ics
            store_data = cp_action.store_data
    
        @action.register(Write)
        def action_write(cp_action):
            assert len(ics) > 0 and len(sol) > 0
            if len(ics) > 0:
                assert cp_action.n == max(ics)
            snapshots[cp_action.storage][cp_action.n] = (set(ics), set(sol))
    
        @action.register(WriteForward)
        def action_write_forward(cp_action):
            assert len(ics) == 0 and len(data) > 0
            assert cp_action.n == max(data)
            assert data == cp_schedule.forward_data
            fwd_chk['RAM'][cp_action.n] = (set(data), set(sol))
    
        @action.register(Forward)
        def action_forward(cp_action):
            nonlocal model_n
            nonlocal sol
            assert model_n is not None and model_n == cp_action.n0
            assert cp_action.n0 < cp_action.n1
            assert len(sol) == 1 and cp_action.n0 in sol
            if cp_schedule.max_n() is not None:
                # Do not advance further than the current location of the adjoint
                assert cp_action.n1 <= n - model_r
    
            n1 = min(cp_action.n1, n)
            if store_ics:
                # No forward restart data for these steps is stored
                assert n1 not in snapshots["RAM"] and n1 not in snapshots["disk"]
            if store_data:
                assert n1 not in fwd_chk['RAM']
            model_n = n1
            if store_ics:
                ics.add(n1)
            if store_data:
                data.add(n1)
            if n1 == n:
                cp_schedule.finalize(n1)
            sol = set()
            sol.add(n1)
    
        @action.register(Reverse)
        def action_reverse(cp_action):
            nonlocal model_r
            # Start at the current location of the adjoint
            assert cp_action.n1 == n - model_r
            # Advance at least one step
            assert cp_action.n0 < cp_action.n1
            # Non-linear dependency data for these steps is stored
            sol.clear()
    
            model_r += cp_action.n1 - cp_action.n0
            if len(cp_schedule.forward_data) == 0:
                fwd_chk["RAM"].clear()
    
        @action.register(Read)
        def action_read(cp_action):
            nonlocal model_n
           # The checkpoint exists
            assert cp_action.n in snapshots[cp_action.storage]
    
            cp = snapshots[cp_action.storage][cp_action.n]
    
            # No data is currently stored for this step
            assert cp_action.n not in ics
            assert cp_action.n not in data
            # The checkpoint contains forward restart or non-linear dependency data
            assert len(cp[0]) > 0 or len(cp[1]) > 0
    
            # The checkpoint data is before the current location of the adjoint
            # print(cp_action.n, n, model_r)
            assert cp_action.n <= n - model_r
    
            model_n = None
    
            if len(cp[0]) > 0:
                ics.clear()
                ics.update(cp[0])
                model_n = cp_action.n
    
            if len(cp[1]) > 0:
                sol.clear()
                sol.update(cp[1])
    
            if cp_action.delete:
                del snapshots[cp_action.storage][cp_action.n]
    
        @action.register(EndForward)
        def action_end_forward(cp_action):
            # The correct number of forward steps has been taken
            assert model_n is not None and model_n == n
    
        @action.register(EndReverse)
        def action_end_reverse(cp_action):
            nonlocal model_r
    
            assert model_r == cp_schedule.max_n()
            assert len(data) == 0
            if not cp_action.exhausted:
                model_r = 0
    
        # for s in S:
        s=S
        # for p0 in p:
        p0 = p
        print(f"{n=:d} {s=:d}")
    
        model_n = 0
        model_r = 0
        init_condition = 0
        store_ics = False
        store_data = False
        ics = set()
        data = set()
        sol = set()
        snapshots = {"RAM": {}, "disk": {}}
        fwd_chk = {"RAM": {}}
    
        cp_schedule, storage_limits, data_limit = schedule(n, s, p0)  # noqa: E501
        if cp_schedule is None:
            pytest.skip("Incompatible with schedule type")
        assert cp_schedule.n() == 0
        assert cp_schedule.r() == 0
        assert s <= n
        assert cp_schedule.max_n() is None or cp_schedule.max_n() == n
        assert n >= 0
    
        def initial_condition(init_condition, sol, ics):
            """Set the initial condition.
            """
            nonlocal model_n
            sol.add(init_condition)
            ics.add(model_n)
    
        initial_condition(init_condition, sol, ics)
        c = 0
        while True:
            cp_action = next(cp_schedule)
            # print(cp_action, c)
            action(cp_action)
    
            assert model_n is None or model_n == cp_schedule.n()
            assert model_r == cp_schedule.r()
            # Checkpoint storage limits are not exceeded
            for storage_type, storage_limit in storage_limits.items():
>               assert len(snapshots[storage_type]) <= storage_limit
E               assert 20 <= 19
E                +  where 20 = len({0: ({0}, {0}), 5: ({5}, {5}), 10: ({10}, {10}), 15: ({15}, {15}), ...})

tests/test_validity.py:254: AssertionError
______________________ test_validity[1-250-25-h_revolve] _______________________

schedule = <function h_revolve at 0x101b78fe0>, n = 250, S = 25, p = 1

    @pytest.mark.parametrize(
        "schedule",
        [
            #   (memory, {}),
            #  (periodic_disk, {"period": 1}),
            #  (periodic_disk, {"period": 2}),
            #  (periodic_disk, {"period": 7}),
            #  (periodic_disk, {"period": 10}),
            #  (multistage, {}),
            #  (two_level, {"period": 1}),
            #  (two_level, {"period": 2}),
            #  (two_level, {"period": 7}),
            #  (two_level, {"period": 10}),
            pytest.param(
                h_revolve),
            #  (mixed, {})
        ])
    @pytest.mark.parametrize("n, S", [
                                        (25, 5),
                                        (25, 10),
                                        (25, 15),
                                        (100, 10),
                                        (100, 20),
                                        (100, 30),
                                        (250, 25),
                                        (250, 50),
                                        (250, 75),
                                        (250, 100),
                                        (250, 125),
                                        (250, 150)
                                    ])
    @pytest.mark.parametrize("p", [1, 3, 5])
    def test_validity(schedule, n, S, p):
        """Test validity.
    
        Parameters
        ----------
        schedule : object
            Scheduler object.
        n : int
            Number of forward step to execute in the AC graph.
        S : tuple
            The number of slots in each level of memory.
    
        Raises
        ------
        TypeError
            Unexpected action.
        """
        @functools.singledispatch
        def action(cp_action):
            raise TypeError("Unexpected action")
    
        @action.register(Clear)
        def action_clear(cp_action):
            if cp_action.clear_ics:
                ics.clear()
            if cp_action.clear_data:
                data.clear()
    
        @action.register(Configure)
        def action_configure(cp_action):
            nonlocal store_ics, store_data
    
            store_ics = cp_action.store_ics
            store_data = cp_action.store_data
    
        @action.register(Write)
        def action_write(cp_action):
            assert len(ics) > 0 and len(sol) > 0
            if len(ics) > 0:
                assert cp_action.n == max(ics)
            snapshots[cp_action.storage][cp_action.n] = (set(ics), set(sol))
    
        @action.register(WriteForward)
        def action_write_forward(cp_action):
            assert len(ics) == 0 and len(data) > 0
            assert cp_action.n == max(data)
            assert data == cp_schedule.forward_data
            fwd_chk['RAM'][cp_action.n] = (set(data), set(sol))
    
        @action.register(Forward)
        def action_forward(cp_action):
            nonlocal model_n
            nonlocal sol
            assert model_n is not None and model_n == cp_action.n0
            assert cp_action.n0 < cp_action.n1
            assert len(sol) == 1 and cp_action.n0 in sol
            if cp_schedule.max_n() is not None:
                # Do not advance further than the current location of the adjoint
                assert cp_action.n1 <= n - model_r
    
            n1 = min(cp_action.n1, n)
            if store_ics:
                # No forward restart data for these steps is stored
                assert n1 not in snapshots["RAM"] and n1 not in snapshots["disk"]
            if store_data:
                assert n1 not in fwd_chk['RAM']
            model_n = n1
            if store_ics:
                ics.add(n1)
            if store_data:
                data.add(n1)
            if n1 == n:
                cp_schedule.finalize(n1)
            sol = set()
            sol.add(n1)
    
        @action.register(Reverse)
        def action_reverse(cp_action):
            nonlocal model_r
            # Start at the current location of the adjoint
            assert cp_action.n1 == n - model_r
            # Advance at least one step
            assert cp_action.n0 < cp_action.n1
            # Non-linear dependency data for these steps is stored
            sol.clear()
    
            model_r += cp_action.n1 - cp_action.n0
            if len(cp_schedule.forward_data) == 0:
                fwd_chk["RAM"].clear()
    
        @action.register(Read)
        def action_read(cp_action):
            nonlocal model_n
           # The checkpoint exists
            assert cp_action.n in snapshots[cp_action.storage]
    
            cp = snapshots[cp_action.storage][cp_action.n]
    
            # No data is currently stored for this step
            assert cp_action.n not in ics
            assert cp_action.n not in data
            # The checkpoint contains forward restart or non-linear dependency data
            assert len(cp[0]) > 0 or len(cp[1]) > 0
    
            # The checkpoint data is before the current location of the adjoint
            # print(cp_action.n, n, model_r)
            assert cp_action.n <= n - model_r
    
            model_n = None
    
            if len(cp[0]) > 0:
                ics.clear()
                ics.update(cp[0])
                model_n = cp_action.n
    
            if len(cp[1]) > 0:
                sol.clear()
                sol.update(cp[1])
    
            if cp_action.delete:
                del snapshots[cp_action.storage][cp_action.n]
    
        @action.register(EndForward)
        def action_end_forward(cp_action):
            # The correct number of forward steps has been taken
            assert model_n is not None and model_n == n
    
        @action.register(EndReverse)
        def action_end_reverse(cp_action):
            nonlocal model_r
    
            assert model_r == cp_schedule.max_n()
            assert len(data) == 0
            if not cp_action.exhausted:
                model_r = 0
    
        # for s in S:
        s=S
        # for p0 in p:
        p0 = p
        print(f"{n=:d} {s=:d}")
    
        model_n = 0
        model_r = 0
        init_condition = 0
        store_ics = False
        store_data = False
        ics = set()
        data = set()
        sol = set()
        snapshots = {"RAM": {}, "disk": {}}
        fwd_chk = {"RAM": {}}
    
        cp_schedule, storage_limits, data_limit = schedule(n, s, p0)  # noqa: E501
        if cp_schedule is None:
            pytest.skip("Incompatible with schedule type")
        assert cp_schedule.n() == 0
        assert cp_schedule.r() == 0
        assert s <= n
        assert cp_schedule.max_n() is None or cp_schedule.max_n() == n
        assert n >= 0
    
        def initial_condition(init_condition, sol, ics):
            """Set the initial condition.
            """
            nonlocal model_n
            sol.add(init_condition)
            ics.add(model_n)
    
        initial_condition(init_condition, sol, ics)
        c = 0
        while True:
            cp_action = next(cp_schedule)
            # print(cp_action, c)
            action(cp_action)
    
            assert model_n is None or model_n == cp_schedule.n()
            assert model_r == cp_schedule.r()
            # Checkpoint storage limits are not exceeded
            for storage_type, storage_limit in storage_limits.items():
>               assert len(snapshots[storage_type]) <= storage_limit
E               assert 25 <= 24
E                +  where 25 = len({0: ({0}, {0}), 52: ({52}, {52}), 101: ({101}, {101}), 136: ({136}, {136}), ...})

tests/test_validity.py:254: AssertionError
______________________ test_validity[1-250-50-h_revolve] _______________________

schedule = <function h_revolve at 0x101b78fe0>, n = 250, S = 50, p = 1

    @pytest.mark.parametrize(
        "schedule",
        [
            #   (memory, {}),
            #  (periodic_disk, {"period": 1}),
            #  (periodic_disk, {"period": 2}),
            #  (periodic_disk, {"period": 7}),
            #  (periodic_disk, {"period": 10}),
            #  (multistage, {}),
            #  (two_level, {"period": 1}),
            #  (two_level, {"period": 2}),
            #  (two_level, {"period": 7}),
            #  (two_level, {"period": 10}),
            pytest.param(
                h_revolve),
            #  (mixed, {})
        ])
    @pytest.mark.parametrize("n, S", [
                                        (25, 5),
                                        (25, 10),
                                        (25, 15),
                                        (100, 10),
                                        (100, 20),
                                        (100, 30),
                                        (250, 25),
                                        (250, 50),
                                        (250, 75),
                                        (250, 100),
                                        (250, 125),
                                        (250, 150)
                                    ])
    @pytest.mark.parametrize("p", [1, 3, 5])
    def test_validity(schedule, n, S, p):
        """Test validity.
    
        Parameters
        ----------
        schedule : object
            Scheduler object.
        n : int
            Number of forward step to execute in the AC graph.
        S : tuple
            The number of slots in each level of memory.
    
        Raises
        ------
        TypeError
            Unexpected action.
        """
        @functools.singledispatch
        def action(cp_action):
            raise TypeError("Unexpected action")
    
        @action.register(Clear)
        def action_clear(cp_action):
            if cp_action.clear_ics:
                ics.clear()
            if cp_action.clear_data:
                data.clear()
    
        @action.register(Configure)
        def action_configure(cp_action):
            nonlocal store_ics, store_data
    
            store_ics = cp_action.store_ics
            store_data = cp_action.store_data
    
        @action.register(Write)
        def action_write(cp_action):
            assert len(ics) > 0 and len(sol) > 0
            if len(ics) > 0:
                assert cp_action.n == max(ics)
            snapshots[cp_action.storage][cp_action.n] = (set(ics), set(sol))
    
        @action.register(WriteForward)
        def action_write_forward(cp_action):
            assert len(ics) == 0 and len(data) > 0
            assert cp_action.n == max(data)
            assert data == cp_schedule.forward_data
            fwd_chk['RAM'][cp_action.n] = (set(data), set(sol))
    
        @action.register(Forward)
        def action_forward(cp_action):
            nonlocal model_n
            nonlocal sol
            assert model_n is not None and model_n == cp_action.n0
            assert cp_action.n0 < cp_action.n1
            assert len(sol) == 1 and cp_action.n0 in sol
            if cp_schedule.max_n() is not None:
                # Do not advance further than the current location of the adjoint
                assert cp_action.n1 <= n - model_r
    
            n1 = min(cp_action.n1, n)
            if store_ics:
                # No forward restart data for these steps is stored
                assert n1 not in snapshots["RAM"] and n1 not in snapshots["disk"]
            if store_data:
                assert n1 not in fwd_chk['RAM']
            model_n = n1
            if store_ics:
                ics.add(n1)
            if store_data:
                data.add(n1)
            if n1 == n:
                cp_schedule.finalize(n1)
            sol = set()
            sol.add(n1)
    
        @action.register(Reverse)
        def action_reverse(cp_action):
            nonlocal model_r
            # Start at the current location of the adjoint
            assert cp_action.n1 == n - model_r
            # Advance at least one step
            assert cp_action.n0 < cp_action.n1
            # Non-linear dependency data for these steps is stored
            sol.clear()
    
            model_r += cp_action.n1 - cp_action.n0
            if len(cp_schedule.forward_data) == 0:
                fwd_chk["RAM"].clear()
    
        @action.register(Read)
        def action_read(cp_action):
            nonlocal model_n
           # The checkpoint exists
            assert cp_action.n in snapshots[cp_action.storage]
    
            cp = snapshots[cp_action.storage][cp_action.n]
    
            # No data is currently stored for this step
            assert cp_action.n not in ics
            assert cp_action.n not in data
            # The checkpoint contains forward restart or non-linear dependency data
            assert len(cp[0]) > 0 or len(cp[1]) > 0
    
            # The checkpoint data is before the current location of the adjoint
            # print(cp_action.n, n, model_r)
            assert cp_action.n <= n - model_r
    
            model_n = None
    
            if len(cp[0]) > 0:
                ics.clear()
                ics.update(cp[0])
                model_n = cp_action.n
    
            if len(cp[1]) > 0:
                sol.clear()
                sol.update(cp[1])
    
            if cp_action.delete:
                del snapshots[cp_action.storage][cp_action.n]
    
        @action.register(EndForward)
        def action_end_forward(cp_action):
            # The correct number of forward steps has been taken
            assert model_n is not None and model_n == n
    
        @action.register(EndReverse)
        def action_end_reverse(cp_action):
            nonlocal model_r
    
            assert model_r == cp_schedule.max_n()
            assert len(data) == 0
            if not cp_action.exhausted:
                model_r = 0
    
        # for s in S:
        s=S
        # for p0 in p:
        p0 = p
        print(f"{n=:d} {s=:d}")
    
        model_n = 0
        model_r = 0
        init_condition = 0
        store_ics = False
        store_data = False
        ics = set()
        data = set()
        sol = set()
        snapshots = {"RAM": {}, "disk": {}}
        fwd_chk = {"RAM": {}}
    
        cp_schedule, storage_limits, data_limit = schedule(n, s, p0)  # noqa: E501
        if cp_schedule is None:
            pytest.skip("Incompatible with schedule type")
        assert cp_schedule.n() == 0
        assert cp_schedule.r() == 0
        assert s <= n
        assert cp_schedule.max_n() is None or cp_schedule.max_n() == n
        assert n >= 0
    
        def initial_condition(init_condition, sol, ics):
            """Set the initial condition.
            """
            nonlocal model_n
            sol.add(init_condition)
            ics.add(model_n)
    
        initial_condition(init_condition, sol, ics)
        c = 0
        while True:
            cp_action = next(cp_schedule)
            # print(cp_action, c)
            action(cp_action)
    
            assert model_n is None or model_n == cp_schedule.n()
            assert model_r == cp_schedule.r()
            # Checkpoint storage limits are not exceeded
            for storage_type, storage_limit in storage_limits.items():
>               assert len(snapshots[storage_type]) <= storage_limit
E               assert 50 <= 49
E                +  where 50 = len({0: ({0}, {0}), 2: ({2}, {2}), 7: ({7}, {7}), 12: ({12}, {12}), ...})

tests/test_validity.py:254: AssertionError
=========================== short test summary info ============================
FAILED tests/test_validity.py::test_validity[1-25-5-h_revolve] - assert 5 <= 4
FAILED tests/test_validity.py::test_validity[1-100-10-h_revolve] - assert 10 ...
FAILED tests/test_validity.py::test_validity[1-100-20-h_revolve] - assert 20 ...
FAILED tests/test_validity.py::test_validity[1-250-25-h_revolve] - assert 25 ...
FAILED tests/test_validity.py::test_validity[1-250-50-h_revolve] - assert 50 ...
========================= 5 failed, 31 passed in 5.11s =========================
